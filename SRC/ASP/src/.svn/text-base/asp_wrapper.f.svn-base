!! ASP (c), 2004-2016, Matt Alvarado (malvarad@aer.com)
!! Based on MELAM of H.D.Steele (c) 2000-2004
!!
!! File Description:
!! asp_wrapper.f - wrapper between STILT and ASP

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! UPDATE HISTORY						                                     !!
!!									                                         !!
!! Month  Year   Name              Description				                 !!
!! 06     2016   Matt Alvarado     Began Update History			             !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! DEPENDENCIES	                            !!
!! 1. ModelParameters			            !!
!! 2. GridPointFields			            !!
!! 3. Aerosols				                !!
!! 4. Condensation			                !!
!! 5. Time				                    !!
!! 6. StepASP                               !!
!! 7. Chemistry                             !!
!! 8. OutputRoutines                        !!
!! 9. Coagulation                           !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! This file contains the following functions and subroutines:	    !!	
!! 1. SUBROUTINE initialize_specificCB4Conc                         !!
!! 2. SUBROUTINE initialize_allCB4MappingConc                       !!
!! 3. SUBROUTINE copy_specificCB4Conc                               !!
!! 4. SUBROUTINE initializeCB4Struct                                !!
!! 5. SUBROUTINE copyDirtStruct                                     !!
!! 6. SUBROUTINE printDirtVector                                    !!
!! 7. SUBROUTINE copyDirtVector                                     !!
!! 8. SUBROUTINE copyAerosoldirtVector                              !!
!! 9. SUBROUTINE combine_or_split_dirt_adirt                        !!
!! 10. SUBROUTINE cb_readCB4File                                    !!
!! 11. SUBROUTINE setDefaultDirt                                    !!
!! 12. FUNCTION getDirtIndex
!! 13. subroutine mapGasConc
!! 14. subroutine initializeMappingStruct
!! 15. subroutine setOneSpeciesMap
!! 16. function getNumCommas
!! 17. subroutine readCB4ASPMappingFile
!! 18. subroutine hysplit_initialize_asp
!! 19. subroutine convert_gas_concs_units_in_place
!! 20. subroutine convert_gas_concs_units
!! 21. function getNonGasChemicalName
!! 22. subroutine stack_non_gas_chemical_names
!! 23. subroutine hysplit_wrapper
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module asp_wrapper
!use StringIO
!include "DEFCONC.INC"


public :: defaultPsetGas, mappingStruct, countSpecies, gasConcMapping,&
      GasConcCopy, hysplit_initialize_asp, cb_readcb4file,&
      hysplit_wrapper, initializecb4struct, copyDirtStruct, &
      printdirtvector, copydirtvector, &
      initialize_specificcb4conc, initialize_allcb4mappingconc, &
      copy_specificcb4conc, combine_or_split_dirt_adirt, adirtConcMapping, &
      copyAerosolDirtVector
!public :: defaultPsetGas

!use makeCB4_to_ASP_Mapping
!use ModelParameters
!use StepASP
!use Chemistry !, ONLY : RecalculatePhotoRatesSZA
include 'DEFCONC.INC'


      type(cb4MappingStruct) :: mappingStruct
      type(allCB4MappingConc) :: gasConcMapping, adirtConcMapping
      type(pset) :: defaultPsetGas

contains
      subroutine initialize_specificCB4Conc(conc)
      implicit none

      type(specificCB4Conc), intent(out) :: conc

      conc%cb4SpeciesName = emptySpeciesName
      conc%numASPSpecies = 0
      if (allocated(conc%namesOfASPSpecies)) &
         deallocate(conc%namesOfASPSpecies)
      if (allocated(conc%indicesOfASPSpecies)) &
         deallocate(conc%indicesOfASPSpecies)
      
      return
      end subroutine
!
! --------------------------
!
      subroutine initialize_allCB4MappingConc(flag)
      implicit none

      integer, intent(in) :: flag
      integer :: i

      if (flag .eq. 0) then
        gasConcMapping%totalNumCB4Species = 0
        gasConcMapping%totalNumASPSpecies = 0
        do i = 1, maxMappingSpecies
            call initialize_specificCB4Conc(gasConcMapping%speciesMap(i))
        enddo
      else
        adirtConcMapping%totalNumCB4Species = 0
        adirtConcMapping%totalNumASPSpecies = 0
        do i = 1, maxMappingSpecies
            call initialize_specificCB4Conc(adirtConcMapping%speciesMap(i))
        enddo
      endif
      
      return
      end subroutine
!
! -----------------------
!

!
! --------------------------
!
      subroutine copy_specificCB4Conc(source, destination)
      implicit none

      type(specificCB4Conc), intent(in) :: source
      type(specificCB4Conc), intent(out) :: destination

      call initialize_specificCB4Conc(destination)
      destination%cb4SpeciesName = source%cb4SpeciesName
      
      ! Don't copy over if nothing is available
      if (source%numASPSpecies .gt. 0) then
          destination%numASPSpecies = source%numASPSpecies
          allocate(destination%namesOfASPSpecies(&
                   destination%numASPSpecies))
          allocate(destination%indicesOfASPSpecies(&
                   destination%numASPSpecies))

          destination%namesOfASPSpecies(:) = &
            source%namesOfASPSpecies(:)
          destination%indicesOfASPSpecies(:) = &
            source%indicesOFASPSpecies(:)
      endif

      return
      end subroutine copy_specificCB4Conc
!
! -----------------------------
!
      subroutine initializeCB4Struct(defaultPsetGasl)
      implicit none

      TYPE(pset), intent(INOUT) :: defaultPsetGasl
      defaultPsetGasl%ident = emptySpeciesName
      defaultPsetGasl%qrate = 0.0
      defaultPsetGasl%qhrs = 0.0
      defaultPsetGasl%start%yr = 0
      defaultPsetGasl%start%mo = 0
      defaultPsetGasl%start%da = 0
      defaultPsetGasl%start%hr = 0
      defaultPsetGasl%start%mn = 0
      defaultPsetGasl%start%ic = 0
      defaultPsetGasl%start%macc = 0
      defaultPsetGasl%dowet = .FALSE.
      defaultPsetGasl%dodry = .FALSE.
      defaultPsetGasl%dorad = .FALSE.
      defaultPsetGasl%dores = .FALSE.
      defaultPsetGasl%dogas = .FALSE.
      defaultPsetGasl%dogrv = .FALSE.
      defaultPsetGasl%dosus = .FALSE.
      defaultPsetGasl%dovol = .FALSE.
      defaultPsetGasl%wetin = 0.0 
      defaultPsetGasl%wetlo = 0.0 
      defaultPsetGasl%wetgas = 0.0 
      defaultPsetGasl%henry = 0.0 
      defaultPsetGasl%dryvl = 0.0 
      defaultPsetGasl%pdens = 0.0 
      defaultPsetGasl%pdiam = 0.0 
      defaultPsetGasl%shape = 0.0 
      defaultPsetGasl%rhalf = 0.0 
      defaultPsetGasl%gpmol = 0.0 
      defaultPsetGasl%acvty = 0.0 
      defaultPsetGasl%difty = 0.0 
      defaultPsetGasl%srate = 0.0

      return
      end subroutine initializeCB4Struct
!
! --------------------
!
      subroutine copyDirtStruct(source, destination)
      implicit none

      !include 'DEFCONC.INC'
      type(pset), intent(in) :: source
      type(pset), intent(out) :: destination

      destination%ident = source%ident
      destination%qrate = source%qrate
      destination%qhrs = source%qhrs
      destination%start%yr = source%start%yr
      destination%start%mo = source%start%mo
      destination%start%da = source%start%da
      destination%start%hr = source%start%mn
      destination%start%mn = source%start%mn
      destination%start%ic = source%start%ic
      destination%start%macc = source%start%macc
      destination%dowet = source%dowet
      destination%dodry = source%dodry
      destination%dorad = source%dorad
      destination%dores = source%dores
      destination%dogas = source%dogas
      destination%dogrv = source%dogrv
      destination%dosus = source%dosus
      destination%dovol = source%dovol
      destination%wetin = source%wetin
      destination%wetlo = source%wetlo
      destination%wetgas = source%wetgas
      destination%henry = source%henry
      destination%dryvl = source%dryvl
      destination%pdens = source%pdens
      destination%pdiam = source%pdiam
      destination%shape = source%shape
      destination%rhalf = source%rhalf
      destination%gpmol = source%gpmol
      destination%acvty = source%acvty
      destination%difty = source%difty
      destination%srate = source%srate
      
      end subroutine copyDirtStruct
!
! --------------------------------------------
!
      subroutine printDirtVector(dirt, numtyp, iunit)
      implicit none

      type(pset), intent(in) :: dirt(:)
      integer, intent(in) :: numtyp
      integer, intent(in), optional :: iunit
      integer :: i, ounit
      
      ounit = 6
      if (present(iunit)) ounit = iunit
      
      do i = 1, numtyp
        write(ounit,*) ''
        write(ounit, *) 'I = ', i
        write(ounit,'(A,A)') 'Species Identifier: ', &
                dirt(i)%ident(1:len(trim(dirt(i)%ident)))
        write(ounit,*) 'qrate, qhrs = ', dirt(i)%qrate, dirt(i)%qhrs
        write(ounit,*) 'start = ', dirt(i)%start%yr, dirt(i)%start%mo, dirt(i)%start%da, &
                dirt(i)%start%hr, dirt(i)%start%mn, dirt(i)%start%ic, dirt(i)%start%macc
        write(ounit,*) 'dowet, dodry, dorad, dores = ', dirt(i)%dowet, dirt(i)%dodry, &
                dirt(i)%dorad, dirt(i)%dores
        write(ounit,*) 'dogas, dogrv, dosus, dovol = ', dirt(i)%dogas, dirt(i)%dogrv, &
                dirt(i)%dosus, dirt(i)%dovol
        write(ounit,*) 'wetin, wetlo, wetgas = ', dirt(i)%wetin, dirt(i)%wetlo, dirt(i)%wetgas
        write(ounit,*) 'henry, dryvl, pdens, pdiam = ', dirt(i)%henry, dirt(i)%dryvl, &
                dirt(i)%pdens, dirt(i)%pdiam
        write(ounit,*) 'shape, rhalf, gpmol = ', dirt(i)%shape, dirt(i)%rhalf, dirt(i)%gpmol
        write(ounit,*) 'acvty, difty, srate = ', dirt(i)%acvty, dirt(i)%difty, dirt(i)%srate
      enddo               
      ! TODO
      end subroutine
!
! -----------------------
!
      subroutine copyDirtVector(psetVect, dirt, veclength, reorder_flag)
      use Chemistry, ONLY : GasPhaseChemicalNames
      implicit none
      
      !include 'DEFCONC.INC'


      type(psetvector), intent(in) :: psetVect
      type(pset), allocatable, intent(inout) :: dirt(:)
      logical, intent(in), optional :: reorder_flag
      integer, intent(out) :: veclength
      integer :: iter, allo_status, new_iter, given_index, species_len
      logical :: to_reorder
      
      to_reorder = .false.
      if (present(reorder_flag)) to_reorder = reorder_flag
      new_iter = 0
      
      if (.not. allocated(psetVect%species)) then
          print *, 'Error: Logic error - psetVect is not ', &
                   'allocated in copyDirtVector()'
          veclength = 0
      else
          vecLength = psetvect%vecLength
          if (allocated(dirt)) deallocate(dirt)
          allocate(dirt(veclength), stat=allo_status)
          if (allo_status .ne. 0) then
              stop 'Unable to allocate space for dirt vector copy'
          endif

          if (size(GasPhaseChemicalNames) .ne. vecLength) then
              print *, 'Error (STILT-ASP): '
          endif
          
          do iter = 1, size(GasPhaseChemicalNames)
             if (.not. to_reorder) then
                 call copyDirtStruct(psetVect%species(iter), dirt(iter))
             else
                 given_index = 0
                 do while (any(psetvect%species(:)%ident == GasPhaseChemicalNames(iter)) .and. &
                         psetvect%species(given_index)%ident .ne. GasPhaseChemicalNames(iter))
                     given_index = given_index + 1
                 enddo       
                 
                 if (given_index .eq. 0) then
                    print *, 'Error (STILT-ASP): '
                    stop
                 else
                    call copyDirtStruct(psetvect%species(given_index), dirt(iter))
                 endif
             endif
          enddo
          
!          do iter = 1, veclength
!            if (.not. to_reorder) then
!                call copyDirtStruct(psetVect%species(iter), dirt(iter))
!            else
!                !species_len = len(trim(psetVect%species(iter)))
!                given_index = 0
!                do while (any(GasPhaseChemicalNames == psetVect%species(iter)) .and. &
!                        GasPhaseChemicalNames(given_index) .ne. psetVect%species(iter))
!                    given_index = given_index + 1
!                enddo
!                
!                    
!                    
!          enddo
      endif

      return
      end subroutine copyDirtVector
!
! -------------------------------
!
      subroutine copyAerosoldirtVector(psetVect, adirt, veclength, reorder_flag)
      use Chemistry, ONLY : HowManyAqChems, HowManyAqCations, &
            HowManyAqAnions, HowManyOrgChems, HowManyAqOrgChems
      implicit none
      
      !include 'DEFCONC.INC'


      type(psetvector), intent(in) :: psetVect
      type(pset), allocatable, intent(inout) :: adirt(:)
      logical, intent(in), optional :: reorder_flag
      integer, intent(out) :: veclength
      integer :: iter, allo_status, new_iter, given_index, species_len
      integer :: num_asp_aerosols
      logical :: to_reorder
      character(len=1024) :: aerosolName
      
      to_reorder = .false.
      if (present(reorder_flag)) to_reorder = reorder_flag
      new_iter = 0
      num_asp_aerosols = 0
      
      if (.not. allocated(psetVect%species)) then
          print *, 'Error: Logic error - psetVect is not ', &
                   'allocated in copydirtVector()'
          veclength = 0
      else
          num_asp_aerosols = HowManyAqChems + HowManyAqCations + &
                HowManyAqAnions + HowManyOrgChems + HowManyAqOrgChems
          vecLength = psetvect%vecLength
          if (allocated(adirt)) deallocate(adirt)
          allocate(adirt(veclength), stat=allo_status)
          if (allo_status .ne. 0) then
              stop 'Unable to allocate space for adirt vector copy'
          endif

          ! TODO
          !if (size( .ne. vecLength) then
          !    print *, 'Error (STILT-ASP): '
          !endif
          
          do iter = 1, num_asp_aerosols !size(GasPhaseChemicalNames)
             aerosolName = getNonGasChemicalName(iter)
             if (.not. to_reorder) then
                 call copydirtStruct(psetVect%species(iter), adirt(iter))
             else
                 !given_index = 0
				 given_index = 1
                 do while (any(psetvect%species(:)%ident == aerosolName) .and. &
                        !GasPhaseChemicalNames(iter)) .and. &
                         psetvect%species(given_index)%ident .ne. aerosolName)
                     given_index = given_index + 1
                 enddo       
                 
                 if (given_index .eq. 0) then
                    print *, 'Error (STILT-ASP): Species Name "', aerosolName, &
                            '" not found in pset vector for aerosols!'
                    stop
                 else
                    call copydirtStruct(psetvect%species(given_index), adirt(iter))
                 endif
             endif
          enddo
          
!          do iter = 1, veclength
!            if (.not. to_reorder) then
!                call copyadirtStruct(psetVect%species(iter), adirt(iter))
!            else
!                !species_len = len(trim(psetVect%species(iter)))
!                !given_index = 0
!				 given_index = 1
!                do while (any(GasPhaseChemicalNames == psetVect%species(iter)) .and. &
!                        GasPhaseChemicalNames(given_index) .ne. psetVect%species(iter))
!                    given_index = given_index + 1
!                enddo
!                
!                    
!                    
!          enddo
      endif

      return
      end subroutine copyAerosoldirtVector
!
! --------------------------------
!
      subroutine combine_or_split_dirt_adirt(combo, dirt, adirt, &
                                             numdirt, numadirt, &
                                             processing_flag)
      implicit none

      type(pset), allocatable, intent(inout) :: combo(:)
      type(pset), allocatable, intent(inout) :: dirt(:), adirt(:)
      integer, intent(inout) :: numdirt, numadirt
      integer :: allo_status, i, processing_flag

      ! Create combo or dirt/adirt
      if (processing_flag .eq. 1) then
          if (allocated(combo)) deallocate(combo)
          allocate(combo(numdirt + numadirt), stat=allo_status)
          if (allo_status .ne. 0) then
              print *, 'Unable to allocate the dirt+adirt combo structure'
              stop
          endif        
      else if (processing_flag .eq. -1) then
          if (allocated(dirt)) deallocate(dirt)
          if (allocated(adirt)) deallocate(adirt)
          allocate(dirt(numdirt), adirt(numadirt), stat=allo_status)
          if (allo_status .ne. 0) then
              print *, 'Unable to allocate dirt and/or adirt structures'
              stop
          endif
      endif

      do i = 1, numdirt
          if (processing_flag .eq. 1) then
              call copyDirtStruct(dirt(i), combo(i))
          else if (processing_flag .eq. -1) then
              call copyDirtStruct(combo(i), dirt(i))
         endif
      enddo
      do i = numdirt + 1, numdirt + numadirt
          if (processing_flag .eq. 1) then
              call copyDirtStruct(adirt(i - numdirt), combo(i))
          else if (processing_flag .eq. -1) then
              call copyDirtStruct(combo(i), adirt(i - numdirt))
          endif
      enddo

      return
      end subroutine
!
! --------------------
!
      subroutine cb_readCB4File(file_name, file_data, return_status, &
                                cdep, rdep, sdep, ibyr, ibmo, ibda, &
                                ibhr)
      implicit none
      
      !include 'DEFCONC.INC'


      

      character(len=*), intent(IN) :: file_name 
      type(psetVector), intent(OUT) :: file_data
      integer, intent(OUT) :: return_status
      logical, intent(OUT) :: cdep, rdep, sdep
      integer, intent(in) :: ibyr, ibmo, ibda, ibhr

      integer :: io_status, allo_status1, iter, macc, numspecs
      integer :: allo_status2
      logical :: is_file
      character(len=maxSpeciesNameLength), ALLOCATABLE :: allSpeciesNames(:)

      file_data%vecLength = 0
      io_status = 0
      cdep = .false.
      rdep = .false.
      sdep = .false.

      inquire(file=file_name(1:len(trim(file_name))), exist=is_file)
      open(unit=88, FILE=file_name(1:len(trim(file_name))), &
           form='formatted', status='old', &
           iostat=return_status)

      if (return_status .ne. 0) then
          print *, 'Error (cb_readCB4File.f90): Unable to read file:'
          print *, file_name(1:len(trim(file_name)))
          
          if (is_file) then
              print *, 'File exists but cannot be opened'
          else
              print *, 'File does not exist'
          endif

          print *, 'Exiting routine with prejudice...'
          return_status = -2
          return
      endif

      read(88, *) file_data%vecLength
      allocate(file_data%species(file_data%vecLength), &
               stat=allo_status1)
      allocate(allSpeciesNames(file_data%vecLength), &
               stat=allo_status2)
      if ((allo_status1 .ne. 0) .or. (allo_status2 .ne. 0)) then
          print *, 'Error (cb_readCB4File): memory ',&
                   'allocation problems'
          print *, 'Pollutant description - Error # ', &
                   allo_status1, allo_status2
          file_data%vecLength = 0
          return_status = -1

          if (allocated(allSpeciesNames))  deallocate(allSpeciesNames)
          if (allocated(file_data%species))deallocate(file_data%species)
          return
      else
          do iter = 1, file_data%vecLength
            call initializeCB4Struct(file_data%species(iter))
            
            ! TODO: Fortran's fixed-length string concept is TERRIBLE.
            read(88, '(A16)') file_data%species(iter)%ident
            read(88, *) file_data%species(iter)%qrate
            read(88, *) file_data%species(iter)%qhrs
            
            ! Copy species name to debugger array (TODO)
            allSpeciesNames(iter) = file_data%species(iter)%ident

            call decodi(88, file_data%species(iter)%start%yr, &
                        file_data%species(iter)%start%mo, &
                        file_data%species(iter)%start%da, &
                        file_data%species(iter)%start%hr, &
                        file_data%species(iter)%start%mn)
         
            ! if month=0 then convert relative time to absolute time
            IF (file_data%species(iter)%START%MO.EQ.0)THEN
                file_data%species(iter)%START%YR=IBYR
                file_data%species(iter)%START%MO=IBMO
                file_data%species(iter)%START%DA=&
                    file_data%species(iter)%START%DA+IBDA
                file_data%species(iter)%START%HR=&
                    file_data%species(iter)%START%HR+IBHR
    
                ! adjust relative date for potential month crossing error
                CALL TM2MIN(file_data%species(iter)%START%YR,&
                            file_data%species(iter)%START%MO,&
                            file_data%species(iter)%START%DA,&
                            file_data%species(iter)%START%HR,&
                            file_data%species(iter)%START%MN, MACC)
                CALL TM2DAY(MACC,file_data%species(iter)%START%YR,&
                            file_data%species(iter)%START%MO,&
                            file_data%species(iter)%START%DA,&
                            file_data%species(iter)%START%HR,&
                            file_data%species(iter)%START%MN)
            END IF
    
            CALL TM2MIN(file_data%species(iter)%START%YR, &
                        file_data%species(iter)%START%MO, &
                        file_data%species(iter)%START%DA, &
                        file_data%species(iter)%START%HR, &
                        file_data%species(iter)%START%MN, &
                        file_data%species(iter)%START%MACC)
          enddo

          read(88, *) numspecs
          if (numspecs .ne. file_data%vecLength) then
              print *, 'WARNING (cb_readCB4file.f90): ', &
                       'Number of pollutants (', file_data%vecLength,&
                       ') is already defined.  TODO!'
              return_status = 0
          endif
          
          ! The original developers did not actually perform any checks
          ! to verify that the species in the second data block are
          ! lined up in the same order as in the first.  Since this is
          ! nothing more than a temporary kludge, let's let it go for
          ! now.
          do iter = 1, file_data%vecLength
            READ(88, *) file_data%species(iter)%PDIAM, &
                        file_data%species(iter)%PDENS, &
                        file_data%species(iter)%SHAPE
            
            IF (file_data%species(iter)%PDIAM.EQ.0.0 .OR. &
                file_data%species(iter)%PDENS.EQ.0.0 .OR. &
                file_data%species(iter)%SHAPE.EQ.0.0) then
                file_data%species(iter)%DOGAS=.TRUE.
            endif
            
            READ(88, *) file_data%species(iter)%DRYVL, &
                        file_data%species(iter)%GPMOL, &
                        file_data%species(iter)%ACVTY, &
                        file_data%species(iter)%DIFTY, &
                        file_data%species(iter)%HENRY
            
            IF(file_data%species(iter)%DRYVL.GT.0.0) then
                file_data%species(iter)%DODRY=.TRUE.
            endif
            
            ! negative molecular weight indicates that emitted mass (kg) will be
            ! converted to volume units (ppm) only in subroutine emsgrd
            IF (file_data%species(iter)%GPMOL.LT.0.0)THEN
                file_data%species(iter)%DOVOL=.TRUE.
                file_data%species(iter)%GPMOL=&
                    ABS(file_data%species(iter)%GPMOL)
            END IF
            
            ! resistence method requires molecular weight for gases
            ! and only diameter for particles, however will use molecular
            ! weight as the turn-on resistence flag for both particles and gases
            IF (file_data%species(iter)%GPMOL.GT.0.0)THEN
                file_data%species(iter)%DORES=.TRUE.
            
                IF(file_data%species(iter)%DOGAS)THEN   
                    IF((file_data%species(iter)%DRYVL+&
                        file_data%species(iter)%ACVTY+&
                        file_data%species(iter)%DIFTY+&
                        file_data%species(iter)%HENRY).EQ.0.0) then
                        file_data%species(iter)%DORES=.FALSE.
                    endif
                 END IF
            END IF
            
            ! check for consistent inputs for gravitational settling
            file_data%species(iter)%DOGRV=.FALSE.
            IF (file_data%species(iter)%PDIAM.GT.0.0.AND. &
                file_data%species(iter)%PDENS.GT.0.0.AND. &
                file_data%species(iter)%SHAPE.GT.0.0) then
                file_data%species(iter)%DOGRV=.TRUE.
            endif
            
            ! specified dry deposition over-rides gravitational settling
            ! and resistance method specification
            IF (file_data%species(iter)%DRYVL.GT.0.0)THEN
                file_data%species(iter)%DOGRV=.FALSE.
                file_data%species(iter)%DORES=.FALSE.
            END IF
            
            READ(88, *) file_data%species(iter)%WETGAS, &
                        file_data%species(iter)%WETIN, &
                        file_data%species(iter)%WETLO
            
            ! check for consistency of wet removal definitions
            IF (file_data%species(iter)%DOGAS)THEN
                
                ! wet removal of gasses only if they are soluable
                file_data%species(iter)%WETIN=0.0
                file_data%species(iter)%WETLO=0.0
            ELSE
                file_data%species(iter)%WETGAS=0.0
            END IF
            
            IF (file_data%species(iter)%WETGAS.GT.0.0 .OR. &
                file_data%species(iter)%WETIN.GT.0.0 .OR. &
                file_data%species(iter)%WETLO .GT.0.0) then
                file_data%species(iter)%DOWET=.TRUE.
            endif
            
            READ(88, *) file_data%species(iter)%RHALF
            IF(file_data%species(iter)%RHALF.GT.0.0) then
                file_data%species(iter)%DORAD=.TRUE.
            endif
            
            READ(88, *) file_data%species(iter)%SRATE
            IF(file_data%species(iter)%SRATE.GT.0.0) then
                file_data%species(iter)%DOSUS=.TRUE.
            endif

            ! If at least 1 species satisfies these conditions, set some
            ! overall conditions.
            IF (file_data%species(iter)%DODRY .OR. &
                file_data%species(iter)%DORES .OR. &
                file_data%species(iter)%DOGRV .OR. &
                file_data%species(iter)%DOWET .OR. &
                file_data%species(iter)%DORAD) CDEP=.TRUE.
    
            IF(file_data%species(iter)%DORES)RDEP=.TRUE.
            IF(file_data%species(iter)%DOSUS)SDEP=.TRUE.

          ! End of loop over each species (second loop)
          enddo

          ! TODO: Do we want to do anything with this array yet?
          deallocate(allSpeciesNames)
          return_status = 1
      
      endif
      close(88)

      return
      end subroutine
!
! -----------------------------
!
      subroutine setDefaultDirt()
      implicit none

      defaultPsetGas%ident = '                '
      defaultPsetGas%qrate = 0.0
      defaultPsetGas%qhrs = 0.0
      defaultPsetGas%start%yr = 0
      defaultPsetGas%start%mo = 0
      defaultPsetGas%start%da = 0
      defaultPsetGas%start%hr = 0
      defaultPsetGas%start%mn = 0
      defaultPsetGas%start%ic = 0
      defaultPsetGas%start%macc = 0
      defaultPsetGas%dowet = .FALSE.
      defaultPsetGas%dodry = .FALSE.
      defaultPsetGas%dorad = .FALSE.
      defaultPsetGas%dores = .FALSE.
      defaultPsetGas%dogas = .FALSE.
      defaultPsetGas%dogrv = .FALSE.
      defaultPsetGas%dosus = .FALSE.
      defaultPsetGas%dovol = .FALSE.
      defaultPsetGas%wetin = 0.0 
      defaultPsetGas%wetlo = 0.0 
      defaultPsetGas%wetgas = 0.0 
      defaultPsetGas%henry = 0.0 
      defaultPsetGas%dryvl = 0.0 
      defaultPsetGas%pdens = 0.0 
      defaultPsetGas%pdiam = 0.0 
      defaultPsetGas%shape = 0.0 
      defaultPsetGas%rhalf = 0.0 
      defaultPsetGas%gpmol = 0.0 
      defaultPsetGas%acvty = 0.0 
      defaultPsetGas%difty = 0.0 
      defaultPsetGas%srate = 0.0

      end subroutine
!
! ------------------------------
!
      integer function getDirtIndex(dirt, numtyp, inputString)
      implicit none

      type(pset), intent(in) :: dirt(:)
      integer, intent(in) :: numtyp
      integer :: iter, wantIndex
      character*(*), intent(in) :: inputString
      character(len=maxSpeciesNameLength) :: ident

      getDirtIndex = 0
      do iter = 1, numtyp
        ident = dirt(iter)%ident
        if (ident(1:len(trim(ident))) .eq. inputString) then
            getDirtIndex = iter
            exit
        endif
      enddo

      return
      end function
!
! -------------------------
!
      subroutine mapGasConc(CB4ConcAll, dirt, numtyp, direction_flag, &
      GasConc, initialize_flag, type_flag)

      use GridPointFields
      use Chemistry    ! already imported above
      use Aerosols
      use Condensation
      use OutputRoutines
      use Coagulation

      implicit none

      !real*8, intent(INOUT) :: GasConc(HowManyEvolveGasChems)
      real*8, allocatable, intent(INOUT) :: CB4ConcAll(:)
      real*8, intent(INOUT) :: GasConc(HowManyEvolveGasChems)
      integer, intent(in) :: type_flag
      logical, intent(inout) :: initialize_flag
      integer, intent(IN) :: direction_flag, numtyp
      type(specificCB4Conc) :: cb4ConcMapPtr
      !type(specificCB4Conc), POINTER :: cb4ConcMapPtr
      type(pset), intent(in) :: dirt(:)
      integer :: cbiter, aspiter, aspsubiter
      integer :: numASPSpecies
      character(maxSpeciesNameLength) :: cb4SpeciesName
      character(maxSpeciesNameLength) :: aspSpeciesName, aspsubname
      !character*(maxSpeciesNameLength), allocatable :: &
      !  namesOfASPSpecies
      !integer, allocatable :: indicesOfASPSpecies
      real*8 :: cb4conc, aspsubconc, aspSpeciesConc
      integer :: dirtIndex, p, i, aerosol_or_gas, asp_iter_lim 
      logical :: to_initialize_asp, gas_flag, aero_flag

      gas_flag = .true.
      aero_flag = .false.
      asp_iter_lim = HowManyEvolveGasChems
      if (type_flag .eq. -1) then
          gas_flag = .false.
          aero_flag = .true.
          !asp_iter_lim = TODO
      endif

      if (.not. allocated(CB4ConcAll)) then
          print *, '***** THIS SHOULD NOT HAPPEN! CB4CONCALL NOT ALLOCATED ', &
                   'WITHIN MAPCONC ******'
          stop
      endif

      to_initialize_asp = .false.
      if (initialize_flag) then
        do i = 1, HowManyEvolveGasChems
            GasConc(i) = 0.0D0
        enddo
        initialize_flag = .false.
      endif
      
      ! Loop over each CB4 key in the mapping structure
      do cbiter = 1, gasConcMapping%totalNumCB4Species
        call copy_specificcb4conc(gasConcMapping%speciesMap(cbiter), &
                                 cb4ConcMapPtr) 

        ! Get the name of the specific CB4 species from mapping struct
        cb4SpeciesName = cb4ConcMapPtr%cb4SpeciesName

        ! Get the amount of ASP species required to properly map the
        ! concentration of this particular CB4 species
        numASPSpecies = cb4ConcMapPtr%numASPSpecies

!        print *, ''
!        print *, 'Cbiter = ', cbiter
!        print *, 'cb4speciesName = ', &
!            cb4SpeciesName(1:len(trim(cb4SpeciesName)))
!        print *, 'num of ASP species required for mapping: ', &
!                  numASPSpecies
!        do p = 1, numASPSpecies
!            print *, 'ASP[', p, '] = ', &
!                cb4ConcMapPtr%namesofASPSpecies(p)(1:len(trim(&
!                cb4ConcMapPtr%namesofASPSpecies(p))))
!        enddo

        ! The species name corresponds to the mapping structure, *NOT*
        ! necessarily the species in a given run.  Need to translate, 
        ! if available...they won't be the same index, most likely.
        dirtIndex = getDirtIndex(dirt, numtyp, &
                cb4SpeciesName(1:len(trim(cb4SpeciesName))))
!        print *, 'dirtIndex = ', dirtIndex
       
        ! If you found the given CB4 mapping species key in the list of
        ! "dirt" files (i.e. run-time inputs), check whether or not you
        ! can get ASP inputs  
        if (dirtIndex .ne. 0) then
!            print *, 'verifying match: ', dirt(dirtIndex)%ident(&
!                    1:len(trim(dirt(dirtIndex)%ident)))

            ! If direction flag is 1, take the CB4 and split it into the ASP
            ! species.  If the direction flag is -1, take the ASP species and
            ! sum up their contributions, storing them in the CB4 structure
            !aspsubconc = 0.0
            if (direction_flag .eq. 1) then
                cb4conc = CB4ConcAll(dirtIndex)
                if (cb4conc .lt. 0.0D0) cb4conc = 0.0D0
            else if (direction_flag .eq. -1) then
                cb4conc = 0.0D0
            else
                print *, 'assertion error, TODO!'
                stop
            endif
!            print *, 'Starting CB4 Conc: ', cb4conc
            
            ! If there is at least one ASP species, we can properly
            ! map the concentrations.  If not, keep it the same  
            if (numASPSpecies .ge. 1) then
!                print *, 'there are ', numASPSpecies, ' ASP species ', &
!                         'for this CB4 species'

                ! For each ASP component map piece...
                aspmaploop : do aspsubiter = 1, numASPSpecies
                    aspsubconc = 0.0D0
                    aspsubname = cb4ConcMapPtr%namesOfASPSpecies(&
                                 aspsubiter)
!                    write(*,*) 'ASP Map Piece = ', aspsubname(1:len(trim(&
!                        aspsubname)))
                    
                    ! Now, check all the species defined internally in ASP.
                    ! We are looking for any of the species defined to be a
                    ! component of the CB4 map.         
                    evolvegasloop : do aspiter = 1, asp_iter_lim
                        if (type_flag .eq. 1) then
                            aspSpeciesName = GasPhaseChemicalNames(aspiter)
                            aspSpeciesConc = GasConc(aspiter)
                        else if (type_flag .eq. -1) then
                            ! TODO
                        endif

!                        print *, '    ASP (Internal) #: ', aspiter
!                        print *, '    ASP Species Name: ',&
!                            aspSpeciesName(1:len(trim(aspSpeciesName)))
!                        print *, '    ASP Conc in GasConc: ', aspSpeciesConc, &
!                            '.'
                        !write(*,'(A,F25.17)') '    ASP Conc in GasConc: ', &
                        !      aspSpeciesConc

                        ! Does this piece correspond to this particular
                        ! ASP mapping name?
                        if (aspsubname(1:len(trim(aspsubname))) .eq. &
                                aspSpeciesName(1:len(trim(&
                                aspSpeciesName)))) then
                            
                            ! If this ASP piece is one of multiple
                            ! species required to properly emulate CB4
                            ! concentration, we only take a fractional
                            ! component of this total.  We will sum each
                            ! component piece to properly get the total.
                            aspsubconc = aspsubconc + aspSpeciesConc/&
                                    dble(numASPSpecies)

                            ! If we are mapping from CB4->ASP, we can
                            ! assign the value here.  This is because
                            ! a single CB4 species  
                            if (direction_flag .eq. 1) then
!                                write(*,'(A,F20.13,A,I3)')       & 
!                                    '        Assigning', cb4conc, &
!                                    ' to ASP species #', &
!                                    aspiter
                                if (type_flag .eq. 1) then
                                    GasConc(aspiter) = cb4conc
                                else if (type_flag .eq. -1) then
                                    ! TODO
                                endif
!                                print *,'       GasConc(', aspiter, ') = ', &
!                                        cb4conc
                                exit evolvegasloop
                            endif
                        endif
                    enddo evolvegasloop
                enddo aspmaploop

                ! If you are mapping from ASP to CB4, take the
                ! weighted sum of each of the ASP component parts
                ! and assign it to the CB4 result.
                if (direction_flag .eq. -1) then
!                    print *, 'dirtIndex = ', dirtIndex
!                    write(*, '(A,F30.15,A)') '    Assigning ', aspsubconc, &
!                        ' to CB4 array'
                    if (aspsubconc .lt. 0.0D0) aspsubconc = 0.0D0 
                    CB4ConcAll(dirtIndex) = aspsubconc
!                    print *, '   CB4ConcAll(', dirtIndex, ') = ', aspsubconc
                endif 



            endif   
        else
!            print *, '--> Not able to find species!!! <--'
!            print *, '--> The DIRT file must not have it?<--'
!            write(*, '(A,A,A)') '--> Species: ', &
!                cb4speciesname(1:len(trim(cb4speciesname))), &
!                '<--'
        endif

        !deallocate(cb4concmapPtr%namesOfASPSpecies)
        !deallocate(cb4concmapPtr%indicesOfASPSpecies)

      enddo ! End of loop over all CB4 species...whew!
      if (allocated(cb4concmapPtr%namesOfASPSpecies)) then
        deallocate(cb4concmapPtr%namesOfASPSpecies)
      endif
      if (allocated(cb4concmapPtr%indicesOfASPSpecies)) then
        deallocate(cb4concmapPtr%indicesOfASPSpecies)
      endif

      return
      end subroutine mapGasConc
!
! ------------------------
!      
      subroutine initializeMappingStruct(veclength)
      implicit none

      integer, intent(in) :: veclength

      integer :: i

      mappingStruct%vecLength = veclength
      allocate(mappingStruct%cb4vector%species(veclength))
      allocate(mappingStruct%cb4vector%species(veclength))
      mappingStruct%cb4vector%vecLength = 0
      mappingStruct%aspvector%vecLength = 0

      do i = 1, mappingStruct%vecLength
        mappingStruct%cb4vector%species(i) = '                '
        mappingStruct%aspvector%species(i) = '                '
      enddo

      return
      end subroutine initializeMappingStruct
!
! ------------------------------
!
      subroutine setOneSpeciesMap(speciesMap, cb4SpeciesName, &
                                  numASPSpecies, namesOfASPSpecies, &
                                  indicesOfASPSpecies)
      implicit none

      type(specificCB4Conc), intent(INOUT) :: speciesMap
      integer, intent(INOUT) :: numASPSpecies
      character(len=maxSpeciesNameLength), allocatable, &
        intent(INOUT) :: namesOfASPSpecies
      character*(*) :: cb4SpeciesName
      integer, allocatable, intent(INOUT) :: indicesOfASPSpecies

      ! TODO: Is this a problem that this gets set multiple times?  
      !       Don't think so.  We can just revise it later if we
      !       need to.  Honestly, it's the least of our problems.  It
      !       is probably faster to assign this each time rather than
      !       applying the conditional anyways...
      speciesMap%cb4SpeciesName = cb4SpeciesName
      speciesMap%numASPSpecies = numASPSpecies

      if (allocated(namesOfASPSpecies)) then
          allocate(speciesMap%namesOfASPSpecies(numASPSpecies))
          speciesMap%namesOfASPSpecies = namesOfASPSpecies
          deallocate(namesOfASPSpecies)
      endif
      if (allocated(indicesOfASPSpecies)) then
          allocate(speciesMap%indicesOfASPSpecies(numASPSpecies))
          speciesMap%indicesOfASPSpecies = indicesOfASPSpecies
          deallocate(indicesOfASPSpecies)
      endif

      end subroutine setOneSpeciesMap
!
! -------------------------
!
! Modified by CMB (AER, Inc) to read from String I/O library instead of
! being called directly
!
      integer function getNumCommas(tstring)
      use StringIO, ONLY: getNumberCommas
      implicit none

      character(len=*), intent(IN) :: tstring
!      integer :: iter, string_length
!      character(len=2) :: charsp
      
      getNumCommas = getNumberCommas(tstring)
      
!      getNumCommas = 0
!      string_length = len(trim(tstring))
!
!      do iter = 1, string_length
!        charsp(1:1) = tstring(iter:iter)
!        if (charsp(1:1) .eq. ',') getNumCommas = getNumCommas + 1
!      enddo

      return
      end function
!
! ------------------------------
!
      subroutine readCB4ASPMappingFile(file_name, return_status, flag)
      !implicit none

      use InfrastructuralCode
      implicit none

      character*(*), intent(in) :: file_name
      integer, intent(out) :: return_status
      character*2 :: specific_char
      !Type(cb4MappingStruct), intent(INOUT) :: mappingStruct

      type(specificCB4Conc) :: tempMapper
      !type(allCB4MappingConc) :: localAllCB4Conc

      character(len=1024) :: asp_line_buffer, line_ptr, cb_string, &
                             asp_string
      logical :: foundNum 
      integer :: veclength, cblineiter, asplineiter, iter, chariter
      integer :: numCommas, specificiter, i, flag
      logical :: is_file
      call setDefaultDirt()
      call initialize_allCB4MappingConc(flag)

      foundNum = .false.
      veclength = 0
      cblineiter = 0
      !cblineiter = 0
      
      inquire(file=file_name(1:len(trim(file_name))), exist=is_file)
      open(unit=77, FILE=file_name(1:len(trim(file_name))), &
           form='formatted', status='old', &
           iostat=return_status)

      if (return_status .ne. 0) then
          print *, 'Error (readCB4ASPMappingFile): Unable to read file:'
          print *, file_name(1:len(trim(file_name)))
          
          if (is_file) then
              print *, 'File exists but cannot be opened'
          else
              print *, 'File does not exist'
          endif

          print *, 'Exiting routine with prejudice...'
          return_status = -2
          return
      endif

      asp_line_buffer = GetLine(77) !'!starting...'
      do while (asp_line_buffer(1:len(trim(EOF))) .ne. EOF)
        !asp_line_buffer = GetLine(77)
        !print *, 'asp_line_buffer = "', &
        !    asp_line_buffer(1:len(trim(asp_line_buffer))), '"'
        !gasConcMapping%speciesMap(cblineiter)%numASPSpecies = 0
        !gasConcMapping%speciesMap(cblineiter)%cb4SpeciesName(&
        !    1:maxSpeciesNameLength) = ''

        call initialize_specificCB4Conc(tempMapper)

        if (asp_line_buffer(1:1) .ne. '!') then
            !print *, '  doesnt start with comment'
            if (.not. foundNum) then
                !print *, '      foundnum=false'
                call GetToken(asp_line_buffer, " ", cb_string)
                !print *, '      token = ', cb_string(&
                !      1:len(trim(cb_string)))
                if (flag .eq. 0) then 
                    gasConcMapping%totalNumCB4Species = STR2INT(cb_string)
                else 
                    adirtConcMapping%totalNumCB4Species = STR2INT(cb_string)
                endif
                !write(*, *) 'numspecies=', &
                !            gasConcMapping%totalNumCB4Species
                !allocate(gasConcMapping%speciesMap(&
                !         gasConcMapping%totalNumCB4Species))
                foundNum = .true.
                !call initializeMappingStruct(vecLength)
            else
                !print *, '  Getting a token...'
                call GetToken(asp_line_buffer, ";", cb_string)
                !print *, '  Token = ',cb_string(1:len(trim(cb_string)))
                
                !gasConcMapping%speciesMap(cblineiter)%cb4SpeciesName(&
                !    1:len(trim(cb_string))) = cb_string(1:len(&
                !        trim(cb_string)))
                tempMapper%cb4SpeciesName = cb_string(&
                    1:len(trim(cb_string)))

                !gasConcMapping%speciesMap(cblineiter)%cb4SpeciesName = &
                !    cb_string(1:len(trim(cb_string)))
                !mappingStruct%cb4vector%species(cblineiter + 1) = &
                !    cb_string
                cblineiter = cblineiter + 1

                ! ASP is different because some species get split up
                ! into multiples.  Need to handle this later...
                !print *, '  Getting a token again...'  
                call GetToken(asp_line_buffer, "!", asp_string)
                !print *,'  Token = ',asp_string(1:len(trim(asp_string)))
                !print *,'  Length = ',len(trim(asp_string))
                ! Count number of commas, which indicates the number of 
                ! ASP species we must allocate
                numCommas = getNumCommas(asp_string)
                !print *, '  Number of commas = ', numCommas

                !gasConcMapping%speciesMap(cblineiter)%numASPSpecies = numCommas + 1
                tempMapper%numASPSpecies = numCommas + 1
                allocate(tempMapper%namesOfASPSpecies(&
                         tempMapper%numASPSpecies))
                allocate(tempMapper%indicesOfASPSpecies(&
                         tempMapper%numASPSpecies))
                do i = 1, tempMapper%numASPSpecies
                    tempMapper%namesOfASPSpecies(i) = emptySpeciesName
                    tempMapper%indicesOfASPSpecies(i) = 0
                enddo


                ! initialize (this deallocates everything)
                !call initialize_specificCB4Conc(&
                !     gasConcMapping%speciesMap(numCommas + 1)) 

                !allocate(gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(&
                !         gasConcMapping%speciesMap(cblineiter)%numASPSpecies))
                !allocate(gasConcMapping%speciesMap(cblineiter)%indicesOfASPSpecies(&
                !         gasConcMapping%speciesMap(cblineiter)%numASPSpecies))

                               
                iter = 1
                specificiter = 1
                do chariter = 1, len(trim(asp_string))
                    if (asp_string(chariter:chariter) .eq. ',') then
                        !tempMapper%namesOfASPSpecies(iter)(1:

                        ! bug fix: fill the rest of the string with blanks so
                        ! that trim will work properly
                        !gasConcMapping%speciesMap(&
                        !    cblineiter)%namesOfASPSpecies(iter)(&
                        !        chariter:maxSpeciesNameLength) = ''

                        !print *, '      Finished species; "', &
                        !    gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(&
                        !        iter)(1:len(trim(gasConcMapping%speciesMap(&
                        !        cblineiter)%namesOfASPSpecies(iter)))), '"'
                        
                        !print *, '     Finished species; "', &
                        !    tempMapper%namesOfASPSpecies(iter)(&
                        !    1:len(trim(tempMapper%namesOFASPSpecies(&
                        !    iter))))

                        specificiter = 1
                        iter = iter + 1
                    else
                        tempMapper%namesOfASPSpecies(iter)(&
                            specificiter:specificiter) = asp_string(&
                                chariter:chariter)

                        !gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(&
                        !    iter)(specificiter:specificiter) = &
                        !        asp_string(chariter:chariter)
                        specificiter = specificiter + 1
                    endif
                enddo

                ! Bug fix for printing - forgot last species
                !print *, '     Finished species; "', &
                !            tempMapper%namesOfASPSpecies(iter)(&
                !            1:len(trim(tempMapper%namesOFASPSpecies(&
                !            iter))))

                ! bug fix: fill the rest of the string with blanks so
                ! that trim will work properly
                !gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(&
                !    iter)(chariter:maxSpeciesNameLength) = ''

                ! Bug fix for printing - forgot last char
                !print *, '      Finished species; "', &
                !            gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(&
                !                iter)(1:len(trim(gasConcMapping%speciesMap(&
                !                cblineiter)%namesOfASPSpecies(iter)))), '"'
                        !specificiter = 1
                        !iter = iter + 1

                         
                ! Find each species
!                do iter = 1, gasConcMapping%speciesMap(cblineiter)%numASPSpecies
!                    write(*, '(I3)') '      Iter = ', iter
!                    !gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(&
!                    !    iter)(1:len(trim(emptySpeciesName))) = &
!                    !        emptySpeciesName(1:len(trim(emptySpeciesName)))
!                    gasConcMapping%speciesMap(cblineiter)%indicesOfASPSpecies(iter) = 0
!
!                    !gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(&
!                    !    iter)(1:len(trim(asp_string))) = &
!                    !        asp_string(1:len(trim(asp_string)))
!                    ! This seems like a repulsive way to extract string
!                    ! data, but Fortran doesn't like null-terminated
!                    ! strings, which is terrible.  
!                    do chariter = 1, len(trim(asp_string))
!                        specific_char(1:1) = asp_string(&
!                                             chariter:chariter)
!                        if (specific_char(1:1) .ne. ',') then
!                            gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies(iter)(&
!                                chariter:chariter) = specific_char(1:1)
!                        else
!                            exit    ! equivalent of C's "break" 
!                        endif
!                    enddo
!                    print *, '
!                enddo
                
                ! check if ASP is not used for this CB4species.  If not,
                ! reset the counter so that nothing is used.  This is
                ! accounted for in the copy struct routine below.
                if (tempMapper%namesOfASPSpecies(1)(&
                        1:lengthCb4NotUsedInASP) .eq. cb4NotUsedInASP)&
                then
                    tempMapper%numASPSpecies = 0
                endif
                 
                ! Copy into the master structure
                if (flag .eq. 0) then
                    call copy_specificcb4conc(tempMapper, &
                        gasConcMapping%speciesMap(cblineiter))
                else
                    call copy_specificcb4conc(tempMapper, &
                        adirtConcMapping%speciesMap(cblineiter))
                endif

                !all setOneMap(tempMapper, gasConcMapping%speciesMap(&
                !               cblineiter))

                ! Copy into the master structure (also deallocates the 
                ! locals)
                !call setOneSpeciesMap(&
                !        gasConcMapping%speciesMap(cblineiter), &
                !        gasConcMapping%speciesMap(cblineiter)%cb4SpeciesName, &
                !        gasConcMapping%speciesMap(cblineiter)%numASPSpecies, &
                !        gasConcMapping%speciesMap(cblineiter)%namesOfASPSpecies, &
                !        gasConcMapping%speciesMap(cblineiter)%indicesOfASPSpecies)

            endif ! have we found the counter line?
        endif ! is this a comment line?

        asp_line_buffer = GetLine(77)

      enddo ! while not EOF
      
      mappingStruct%cb4vector%veclength = cblineiter
      mappingStruct%aspvector%veclength = asplineiter
      close(77)

      return 
      end subroutine
!
! -------------------------------------
!
      subroutine hysplit_initialize_asp(dirt_file_name, adirt_file_name, &
                                        initialize_flag, useaero)
      use StepASP, ONLY : initializeASP

      implicit none


      !type(cb4MappingStruct), intent(INOUT) :: mappingStruct
      character(len=*), intent(in) :: adirt_file_name, dirt_file_name
      integer, intent(in) :: initialize_flag, useaero
      integer :: return_status

      ! Get the array that maps CB4 species to ASP
      !call readCB4ASPMappingFile(dirt_file_name, return_status, 0)
      !call readCB4ASPMappingFile(adirt_file_name, return_status, 1)

      !print *, 'In asp_wrapper(): about to call initialize ASP'
      ! TODO: This may come with arguments later...
      if (initialize_flag .eq. 1) & !then
        call initializeASP(sza=45.0, transmissivity = 1.0, doAerosols=useaero)
      !endif

      ! Now, we need to get the list of Reaction types? 
      !print *, 'done with initializeASP()'
      return
      end subroutine
!
! ------------------------------
! 
      subroutine convert_gas_concs_units_in_place(tpar, ppar, array, direction)
      implicit none
      
      real*8, intent(in) :: ppar, tpar
      real*8, intent(inout) :: array(:)
      integer, intent(in) :: direction
      
      integer :: iter, allo_status
      real*8, allocatable :: temp_array(:)
      
      if (size(array) .gt. 0) then
           allocate(temp_array(size(array)), stat=allo_status)
           if (allo_status .ne. 0) then
               print *, 'Error (convert_gas_concs_units_in_place): Unable to allocate (', &
                       size(array), ') records.  Exiting...'
               stop
           endif
           temp_array(:) = array(:)
           if (direction .eq. 1) then
               call convert_gas_concs_units(tpar, ppar, temp_array, size(temp_array), array, direction)
           else
               call convert_gas_concs_units(tpar, ppar, array, size(array), temp_array, direction)
           endif
      endif      
      end subroutine
!
! --------------------------------
!
      subroutine convert_gas_concs_units(tpar,ppar,cbsum_ppm,numtypes,&
                                         cbsum_molec_cm3, direction)
      implicit none

      real*8, intent(IN) :: ppar
      real*8, intent(IN) :: tpar
      real*8, intent(INOUT) :: cbsum_ppm(:)
      real*8, intent(INOUT) :: cbsum_molec_cm3(:)
      integer, intent(IN) :: numtypes
      real*8 :: factor
      integer :: direction, i ! 1: ppm->molec/cm3, -1: reverse, others: no action

      factor = (ppar*avogadrosnum/R__J_K_mol/tpar/ &
                M3_TO_CM3/1.0E6) ! extra 1e6 is for ppm
!      print *, 'multiplicative factor = ', factor
!      print *, 'this value converts ppmv to molec/cm3'
      
      do i = 1, numtypes
        !print *, 'i = ', i
        if (direction .eq. 1) then
            !print *, '    PPM = ', cbsum_ppm(i) 
            cbsum_molec_cm3(i) = cbsum_ppm(i)*factor
            !print *, '    Molec/cm3 = ', cbsum_molec_cm3(i)
        else if (direction .eq. -1) then
            !print *, '    Molec/cm3 = ', cbsum_molec_cm3(i)
            cbsum_ppm(i) = cbsum_molec_cm3(i)/factor
            !print *, '    PPM = ', cbsum_ppm(i)
        endif
      enddo

      return
      end subroutine
!!
!! ---------------------------------
!!
!! Extremely low level function, manually copies 1 character at a time.  This
!! is done in order to avoid the problems the original ASP GetLine() exhibits
!! when ported to multiple platforms.
!!
!! The only way this could be more basic is if it were in assembly language...
!! 
!! ---------------------------------
!!
!      integer function get_line_new(FUNIT, line, fileend)
!      implicit none
!
!      integer, parameter :: buffer_size = 1024
!      integer, parameter :: comment_char = 33       
!
!      integer :: ibyte
!      logical :: comment_flag
!      integer, intent(inout) :: funit
!      logical, intent(inout) :: fileend
!      character(len=buffer_size), intent(out) :: line
!      character(len=1) :: cbyte 
!
!      ! Newline characters are #10 and #13 (decimal) in the ASCII table.
!      integer :: newlines_or_comments(2), read_status
!      data newlines /10, 13/            ! \n, \r
!      save newlines 
!
!      get_line_new = 0                  ! # of non-newline chars
!      cbyte = char(0)                   ! '\0'
!      line = repeat(' ', buffer_size)   ! make entire string spaces
!      comment_flag = .false.
!
!      charloop : do while(get_line_new .lt. buffer_size)
!
!! The implementation of the stream character reader is compiler-dependent.
!! So far, I've found the following two methods...
!#ifdef IFORT
!          read_status = fgetc(funit, cbyte)
!#elseif GFORTRAN
!          call fgetc(funit, cbyte, read_status)
!#endif
!          ! If there was an error reading the byte
!          if (read_status .eq. funit) then
!               print *, 'Error: There was a problem reading the file!'
!               print *, 'File Unit #:', funit
!               print *, '# of chars read in this particular buffer segment:',&
!                        get_line_new
!               print *, 'Last character read (ASCII#):', ichar(cbyte)
!               print *, 'Are you trying to read a file that is closed?'
!               print *, 'Exiting...'
!               stop
!
!          ! If EOF, close the file and update status accordingly.
!          else if (read_status .eq. -1) then
!              fileend = .true.
!              close(funit)
!              exit charloop
!          
!          ! If read successfully and not EOF    
!          else
!              ibyte = ichar(cbyte)
!
!              ! Break out of loop if \r or \n
!              if (ibyte .eq. any(newlines)) then
!                  exit charloop
!
!              ! If we find a comment character, don't break out of the
!              ! loop but trigger a flag that prevents all remaining chars
!              ! from being added to the string.  This will allow the file
!              ! pointer to keep moving ahead from read to read.
!              ! If we have a non-comment character, move "pointer" ahead a 
!              ! byte and copy the bys over the default (whitespace.)
!              else if (ibyte .eq. comment_char) then
!                  comment_flag = .true.
!              else
!                  if (.not. comment_flag) then
!                      get_line_new = get_line_new + 1
!                      line(get_line_new:get_line_new) = cbyte
!                  endif
!              endif
!
!      enddo charloop
!      return     
!      end function

character(len=1024) function getNonGasChemicalName(indx) result(chemName)
    use Chemistry
    implicit none

    integer :: indx
    character(len=1024) :: tempChemName

    ! TODO: Need to check the "off by 1" errors
    tempchemName = repeat(' ', 1024)
    chemName = repeat(' ', 1024)
    if (indx .le. HowManyAqChems) then
        tempChemName = AqPhaseChemicalNames(indx)
    else if (indx .le. (HowManyAqChems + HowManyAqCations)) then
        tempChemName = AqCationNames(indx - HowManyAqChems)
    else if (indx .le. (HowManyAqChems + HowManyAqCations + HowManyAqAnions)) then
        tempChemName = AqAnionNames(indx - HowManyAqChems - HowManyAqCations)
    else if (indx .le. (HowManyAqChems + HowManyAqCations + HowManyAqAnions + &
                        HowManyOrgChems)) then
        tempChemName = OrgPhaseChemicalNames(indx - HowManyAqChems - HowManyAqAnions - &
                                         HowManyAqCations)
    else
        tempChemName = OrgPhaseChemicalNames(indx - HowManyAqChems - HowManyAqAnions - &
                                         HowManyAqCations - HowManyAqOrgChems)
    endif

    chemName = tempChemName(1:len(trim(tempChemName)))
!    return
end function getNonGasChemicalName

subroutine stack_non_gas_chemical_names(non_gas_chem_names)
    use Chemistry
    use StringIO, ONLY : copyString
    implicit none
    
    character(len=64), intent(out), allocatable :: non_gas_chem_names(:)
    
    integer :: iter, num_asp_species, allo_status, dummy
    character(len=64) :: temp_name
    
    num_asp_species = HowManyAqChems + HowManyAqCations + HowManyAqAnions + &
            HowManyOrgChems + HowManyAqOrgChems
    if (num_asp_species .gt. 0) then
        if (allocated(non_gas_chem_names)) deallocate(non_gas_chem_names)
        allocate(non_gas_chem_names(num_asp_species), stat=allo_status)
        if (allo_status .ne. 0) then
            print *, 'Error(stack_non_gas_chemical_names): Allocation error; ', &
                    'Unable to allocate for (', num_asp_species, ') species.  Exiting...'
            stop
        endif
        
        do iter = 1, num_asp_species
            temp_name = getNonGasChemicalName(iter)
            dummy = copyString(temp_name(1:len(trim(temp_name))), non_gas_chem_names(iter), .true.)     
        end do
    endif
end subroutine
    
!
! ------------------------------------
!
      subroutine hysplit_wrapper(dirt, numtyp, adirt, naddp, &
                                 solarElevationAngle, &
                                 cbsum_ppm, &
                                 tempK, ppar, &   
                                 density, timestep, &
                                 casum_ppm, to_initialize_asp, &
                                 MassConc, NumConc, TermVel, Transmissivity)
      !use GridPointFields
      use Chemistry    ! already imported above
      use Aerosols
      !use Condensation
      !use OutputRoutines
      !use Coagulation
      use StepASP
      use ModelParameters, ONLY : HowManyBins
      !use InfrastructuralCode

     
      implicit none
      !include 'DEFCONC.INC'
      !implicit none

      !! ------------- from ASP ----------------- External Variables
      REAL*8 :: Timestep !(in s)
      !REAL*8 :: Temp  !(in K)
      REAL*8 :: Press !(in mbar)
      REAL*8 :: Dens  !(in kg/m3 dry air)
      REAL*8 :: GasConc(HowManyEvolveGasChems)
      REAL*8 :: NumConc(HowManyBins)
      REAL*8 :: MassConc(HowManyBins, HowManyAqChems+&
                         HowManyAqCations+HowManyAqAnions+&
                         HowManyOrgChems+HowManyAqOrgChems)
      REAL*8 :: Radius(HowManyBins)
      REAL*8 :: TermVel(HowManyBins)
      !REAL*8 :: PhotoRates(12)
      ! CB: Ifort complains unless these dimensions match
      !REAL*8, DIMnENSION(18) :: ExtCoeff, SingScat, Assym
      REAL*8, DIMENSION(451):: ExtCoeff, SingScat, Assym
      ! ---------------------- end from ASP

      integer, intent(in) :: numtyp, naddp
      logical, intent(inout) :: to_initialize_asp
      !type(pset), allocatable, intent(inout) :: dirt(:)
      type(pset), intent(in) :: dirt(:), adirt(:)
      real*8, intent(INOUT) :: cbsum_ppm(:)    ! before
      real*8, intent(INOUT) :: casum_ppm(:)    ! after 
      real*8, intent(in) :: ppar, solarElevationAngle, density
      !real*8, intent(in) :: timestep
      real*8 :: press_mbar, tempK
      real*8, allocatable :: cbsum_molec_cm3(:), casum_molec_cm3(:), &
                             adirt_molec_cm3_1(:), adirt_molec_cm3_2(:) 
      integer :: allo_status, iter
      real*8 :: derp
	  real*8, intent(in) :: Transmissivity !Estimated cloud cover from /STILT-Chem/sunflx.f
	  
      ! bug fix: pressures already in mb
      press_mbar = ppar !/100.0   ! convert to mbar from Pa
 !call flush(678)
      ! 
      !print *, ''
      !print *, '*************************************'
      !print *, 'Inputs to ASP: '
      !print *, 'Number of gas types: ', numtyp
      !print *, 'Number of aerosol types: ', naddp
      !print *, 'Solar Elevation Angle: ', solarElevationAngle
      !print *, 'Temperature (K): ', tempK
      !print *, 'Pressure (mbar): ', press_mbar
      !print *, 'Density: ', density
      !print *, 'Timestep: ', timestep
      !print *, '***************************************'
      !print *, ''
!
! Convert the input concentrations 
!
!     GAS (ppm to molec/cm3)
      !print *, 'Allocating GAS concentration unit mapper and converting ',&
      !         'into molecules/cm3' 
      allocate(cbsum_molec_cm3(numtyp), stat=allo_status)
      if (allo_status .ne. 0) then
          print *, 'Unable to allocate memory for cbsum_molec_cm3'
          stop
      endif
      call convert_gas_concs_units(tempK, ppar, cbsum_ppm, numtyp, &
                                   cbsum_molec_cm3, 1)
                                   
      ! Let's see if we can figure the names out.
      !print *, 'Inside asp_wrapper: Number of types = ', numtyp
      !print *, 'HowManyGasChems = ', HowManyGasChems
      !print *, 'HowManyEvolveGasChems = ', HowManyEvolveGasChems
      GasConc(1:HowManyEvolveGasChems) = cbsum_molec_cm3(1:HowManyEvolveGasChems)
      !do iter = 1, numtyp
      !    if (iter .le. HowManyEvolveGasChems) then
      !        derp = GasConc(iter)
      !    else
      !        derp = cbsum_molec_cm3(iter)
      !    endif
      !    
      !    write(*, '(A, F25.15, F25.15)') GasPhaseChemicalNames(iter), cbsum_molec_cm3(iter), derp
      !enddo
       
!     AEROSOL ( to ug/m3)

      !return
      ! Convert the input concentrations into their ASP
      ! names/processing.  Contents of cbsum_molec_cm3 go into the
      ! public GasConc() array and are not needed anymore here.
      !print *, 'Mapping the GAS concentrations from STILT->ASP'
      !call mapGasConc(cbsum_molec_cm3, dirt, numtyp, 1, GasConc, &
      !             to_initialize_asp, 1)
      !if (allocated(cbsum_molec_cm3)) deallocate(cbsum_molec_cm3)

!      print *, 'Mapping the Aerosol concentrations from STILT->ASP (TODO)'
      !call mapGasConc(aero_temp_1, adirt, naddp, 1, MassConc, &
      !      to_initialize_asp, -1)
      !return    ! debug this

      ! Reset photolysis parameters based on solar zenith angle
      ! UPDATE: Move this after the concentration mapper
      ! TODO: Do I need to include a recalc of ReactionRates?
      !print *, 'Calling RecalculatePhotoRatesSZA with elevation ', &
      !         'angle = ', solarElevationAngle, '.'
      !call RecalculatePhotoRatesSZA(90 - solarElevationAngle, .FALSE.)
      
      !return
      ! apply the ASP model
      !write(678,*) 'asp_wrapper(): Calling ASP Interface'
      !write(*,*) "Before interface NH3 (aq): ", MassConc(1,3)
	  call ASPInterface(timestep, tempK, press_mbar, density, GasConc, &
                        NumConc, MassConc, &
                        !PhotoRates, &
                        ExtCoeff, SingScat, Assym, Radius, TermVel, &
                        90-solarElevationAngle, Transmissivity) 
		!write(345,*) "Radius (um)", Radius(1)*1.0e4				
      !write(*,*) "After interface NH3 (aq): ", MassConc(1,3)	
      !do iter = 1, numtyp
      !    if (iter .le. HowManyEvolveGasChems) then
      !        derp = GasConc(iter)
      !    else
      !        derp = cbsum_molec_cm3(iter)
      !    endif
      !    
      !    write(*, '(A, F25.15, F25.15)') GasPhaseChemicalNames(iter), cbsum_molec_cm3(iter), derp
      !enddo
      
      ! Convert the output concentrations back into the CB4 equivalents
      ! for return to STILT-Chem
      !print *, 'Allocating space for temp STILT array and remapping ',&
      !         'from ASP->STILT'
      allocate(casum_molec_cm3(numtyp), stat=allo_status)
      if (allo_status .ne. 0) then
          print *, 'Unable to allocate memory for casum_molec_cm3'
          stop
      endif

      ! Bugfix: Forgot to re-assign!
      !print *, 'Re-assigning concentrations'
      casum_molec_cm3(1:HowManyEvolveGasChems) = GasConc(1:HowManyEvolveGasChems)
      casum_molec_cm3(HowManyEvolveGasChems + 1:numtyp) =&
            cbsum_molec_cm3(HowManyEvolveGasChems + 1:numtyp)
      
      
      ! Interesting: put a parentheses after GasConc and watch the 
      !              internal ifort error!
      !call mapGasConc(casum_molec_cm3, dirt, numtyp, -1, GasConc, &
      !             to_initialize_asp, 1)
      
      ! Convert the returned concentrations back into ppm and deallocate
      ! the array containing CB4 species concentrations in molec/cm3
      !print *, 'Convert STILT from molec/cm3 back to ppm'
      call convert_gas_concs_units(tempK, ppar, casum_ppm, numtyp, &
                                   casum_molec_cm3, -1)
      if (allocated(casum_molec_cm3)) deallocate(casum_molec_cm3)
      !write(678,*) 'asp_wrapper(): Returning to STILT-Chem...' !print *, 'Returning to STILT-Chem...'
      return
      end subroutine

end module asp_wrapper 
        

        



